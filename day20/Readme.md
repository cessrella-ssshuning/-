530 二叉搜索树的最小绝对差。因为是二叉搜索树，所以如果按照中序遍历的话，每个相邻结点的值是最近的。所以可以设置一个全局变量prev，来比较相邻两个节点的值的差。
并且不断更新这个值，最终返回。要注意这个prev得是全局变量，如果作为参数传入helper函数的话其实并不能得到及时更新。
501 二叉搜索树的众数。其实这一题也是利用了一个全局变量prev。同时为了避免重复遍历，在遍历的过程中就记录两个值，一个是count，一个是最大count。
但凡当前的数又出现了，就更新max count为count，并且这个时候要clear之前存在最终结果list里面的数。如果当前的数是第一次出现，那么count的初始值为1.
如果当前数的count累计到了max count,那么就把这个数加到list里面。
236
二叉树的最近公共祖先。
这题用递归的办法解决。是自底向上进行遍历。首先递归的退出条件是root等于null，或者找到了p或者q。如果没找到p或者q，函数是返回null的。那么如果遍历左边和右边的值
都不为null，也就说明， 当前这个点就是LCA。如果一边为null，那么就返回另一边找到的p或者q，并能一直向上传递。
同时一个节点为另一个节点子节点的情况，也可以涵盖在退出条件里面。
