1. 669 修剪树。这一题如果是递归做的话，是从上向下进行遍历的。
如果是root.val太小，在low下面，那么需要移动遍历到右边，这个时候这些遍历途中的结点实际上已经被删除了。因为我们只会返回右子树。
如果root值太大，超出了这个范围，那么需要移动遍历到左边，相应地，右边的那些被略过的结点也被删除了。
如果是迭代做的话，首先要保证当前这个结点是在区间内的，然后其余的那些节点都被删除了。
此时因为根节点在区间内，对于BST 所以左结点要么就是太小了，右结点要么就是太大了。然后就是两次遍历，一次check左结点，如果小了，那么就一直替换它为它的右结点，直到满足要求为止。
一次check右结点，大了也是一层一层地遍历，对于每一层的每个右结点，看是不是大了，大了就持续替换为它的左结点。
2. 108
这一题就是用递归做，每次都把数组分成两半，传入的还是数组的下标。
3. 538
这一题重要是把这棵树想象成一个数组，就跟presum 一样，利用BST的特性，进行顺序遍历，右左中的遍历。利用一个Pre全局变量来记录presume，
然后可以递归也可以迭代。
