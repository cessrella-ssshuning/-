107 这个followup版的level order。要么递归的时候，改变一下添加进list的顺序，index不再是level，而是倒序的。
同样地，迭代的时候，不再是顺序添加，而是用一个链表，每次添加在表头，这样子就不用reverse了。
199 右视图。这题递归的时候list每层添加一个数，递归的时候，只要改变一下左右子树递归的顺序，也就是先递归右子树。那么此行中最右边一个节点总是先访问到的，这就是我们要添加的结点。
迭代就简单些。迭代只要判断是当前queue里面的最后一个节点就可以添加进去。
515 求每行中最大的数。这个跟199有点类似。递归的时候，先添加前面的数，然后在访问之后节点的时候，比较出大的就给他替换掉。
迭代就是在当前的queue中找出最大的就把这个最大的加入到结果当中。
116
这个把每行节点串联起来。递归的话，因为是满二叉树，所以左边的可以指向右边的，右边的可以指向父节点的左边。然后依次递归即可。
迭代的话，就是每次都pop出来一对节点，然后前面的指向后面的。这个时候留下最后一个节点最后pop，因为它要指向null。然后依次把这些节点的左右子节点加入到queue当中。
117
非满二叉树的串联。迭代的方法是一样的。
但是此时递归的办法略有不同。递归的话，每行都要跟链表一样，设置一个dummy node，然后逐渐往后移。如果有左节点，那么左节点指向右节点。如果有右节点，那么当前指针就指向右节点。
然后父节点的指针也向前移动，即root=root.next。然后继续向前推进子节点的串联。
如果root节点不再有下一个节点，证明当前行的遍历到了尽头。
所以要把root转移到子节点这一行。所以当前结点再次重复利用这个dummy node，cur = dummy; root = cur.next; dummy.next = null; 然后再继续进行这一层的遍历。
111
这个求最小深度的递归。要注意当这棵树只拥有一边的子树，那么很有可能在比较左右两棵子树返回值的时候，一边返回了0，再加上当前的深度1，最后结果是1.但其实这是不对的，因为一边其实并没有depth。
所以当我们遇到左子树或者右子树的返回值为0的时候，我们把结果设置为最大值，那么最小的依然是另一侧子树的返回值。
226
反转树。这个递归比较简单。迭代的话还是用一个queue，每次添加进一个node的时候，反转它的左右子树。就是简单地遍历每一个节点。
101
对称树。这个递归就是用一个helper function，传入的参数是这个节点的左右子节点。判断条件是，如果左右子节点都为空是true，如果只有一个为空或者两者的值不等，那么false。然后递归下去，
递归的是左子树的左节点和右子树的右节点；左子树的右节点和右子树的左节点。
迭代的方法也是一样。就是每次放进queue，放进去的都是对称的两个节点，pop出来的也是一对。对这两个节点的判断条件跟上面是一样的，放进queue的也是两对，左子树的左节点，右子树的右节点这是一对，
另一对的事左子树的右节点和右子树的左节点。
