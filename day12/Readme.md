第一题是用双端队列解决。双端队列里始终保持一个递减的顺序，是因为如果前一个数比新的数小，而且在当前这个window里面离现在的index远，那么永远不可能有用，所以得从当前队列里面出来。
所以如果保持一个递减的队列，并且保持队列这个window的大小固定是k大，然后当队列开始达到size k之后，不断更新maximum值。
第二题可以用priority queue做，也可以用quick select做。
此处先写一下quick select的做法，之后再补充。
首先呢，先把元素根据frequency统计一下。然后quick select， select的是f,就是想找出正好f等于k的时候。然后再把frequency大于等于k的数字放到最后结果里。
这个quick select的写法是随机找一个pivot，然后用左右两个指针。如果左边的数大于pivot，就把这个数换到当前这个index上，然后因为左边的数已经处理过了，所以需要右移当前的index和左边的指针。
如果右边的数小于pivot，就把这个数换到当前index上，这两个数都没有被处理过所以只要左移右边的指针。如果当前的数正好等于pivot那么就继续处理下一个。
记住当前的指针永远指向的是没有处理过的数字。
最后递归的条件是，由于当前的数被分成了三部分，如果右指针和右边界之间的数大于k,那么需要在右边这个部分找到第k大的。
如果左指针和右边界之间的数大于k,那么pivot已经找到了，因为pivot就是这之间的数。
如果这么多数还不够，那么需要从左边界和左指针之间再找一些数，来补充到k个数。

方法二是用小根堆。求前k个最大的，但是用小根堆。小根堆可以一直poll出最小的，可以保证每次重新排序的时候只有固定的k个数。

