513
求最左下节点的值。这题用level order traversal顺其自然，就是一层一层地遍历找到最后一行最左边节点的值。
但是如果递归求的话，要注意一边求depth然后比较这个是不是比之前的depth大，如果大的话就更新，更新到最后这个递归过程结束的时候，最后一次更新就是在最后一行的时候。
这个时候result已经被更新成了最左边最下面那个叶子节点的值。理论上是前序遍历。
112,113
这两题都是path sum，一个是判断有没有path sum，一个是打印出所有的path sum.
如果是要判断有没有path sum，一个就是递归，但是但凡看到sum已经满足条件了，那么就可以返回true了。
一个是打印出来所有的path sum，这个把当前节点的值放到list里面比较tricky，因为放到list里但是list在其后的递归过程中是不断变化的，所以注意加进最后结果的时候要copy结果而不是直接添加。
然后这个sum的值可以直接传入sum+node.val，这样的话在分别进行左右节点递归的时候，sum的值不会直接被更新。
注意有几种选择，一种是一开始进入递归就判断node是不是空，要么就是在递归左右节点的时候判断左右节点是不是为空，但是不管怎么样，在一开始遍历root的时候，value也需要加进到list里面，以防最后一个数没有被加进去。
105，106
这个构造二叉树的都是采用递归。边界十分重要，每次传入的都是index，注意边界不要搞错了。
